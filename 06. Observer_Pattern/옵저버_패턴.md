옵저버 패턴
===

### 01. 개요
<br></br>

* 유니티 개발의 과제는 컴포넌트를 서로 분리하는 좋은 방법을 찾는 것
* API와 인스펙터로 컴포넌트를 직접 참조하는 다양한 방법을 제공
    + 비용이 필요할 수 있음
    + 참조가 누락되어 코드를 취약하게 함
    + 게임이 제대로 작동하지 않을 가능성이 존재

* 옵저버 패턴을 이용하면 컴포넌트 간 연결을 느슨하게 만들고 논리적으로 구성 가능
* 옵저버 패턴을 이용하면 일대다 구조의 이벤트 처리 시스템을 구축 가능
-------------------------------------------

### 02. 옵저버 패턴의 이해
<br></br>

* 옵저버 패턴의 주요 목표
    + 객체 간의 **일대다 관계를 설정**하는 것
    + 주체 역할을 맡는 객체는 내부에서 변경되었을 때 관찰자에게 알릴 의무를 가짐
        - 이는 객체가 특정 이벤트 알림을 구독하고 수신하는 **게시자-구독자 관계와 유사**
        - **주체와 관찰자가 서로를 알고 있어** **가볍게 결합**된다는 차이점 존재

* 주체와 옵저버는 모두 구현해야 할 각각의 인터페이스를 가짐
    + 주체: ISubject
        - AttachObserver(): 알림받을 관찰자 목록에 객체를 추가
        - DetachObserver(): 관찰자 목록에서 관찰자를 제거
        - NotifiyObservers(): 주체의 관찰자 목록에 추가된 모든 객체에 알림을 보냄
    + 옵저버: IObserer
        - Notify(): 주체 객체의 상태가 변경되었을 때 알림
-------------------------------------------

### 03. 옵저버 패턴의 장단점
<br></br>

* 장점
    + 역동성
        - 주체에 필요한 만큼의 객체를 관찰자로 추가하거나 런타임에 동적으로 제거 가능
    + 일대다
        - 일대다 관계가 있는 객체 간 이벤트 처리 시스템의 구현 문제를 우아하게 해결
* 단점
    + 무질서
        - 옵저버 패턴은 관찰자가 알림받는 순서를 보장하지 않음
        - 둘 이상의 옵저버 객체가 종속성을 공유하고 특정 순서에 맞춰 함께 작동해야 한다면 적당하지 않음
    + 누수
        - 주체는 관찰자에 대한 강한 참조를 가져 메모리 누수를 일으킬 가능성이 있음
-------------------------------------------

### 04. 옵저버 패턴을 사용하는 경우
<br></br>

* 상태를 자주 변경하고 변경 사항에 대응해야 하는 종속성이 많은 핵심 컴포넌트가 있는 경우
    + 해당 엔티티와 알림을 받게 하는 메커니즘 간 관계를 정의 가능
    + 옵저버 패턴을 적용하기 전, 객체 간 관계를 확인해야함
-------------------------------------------

### 05. 옵저버 패턴의 구현
<br></br>

* 다른 엔티티와 상호작용하는 등 상태를 변경하고 속성을 가장 자주 변경하는 엔티티는 Player
    + 많은 매니저는 Player가 상태를 변경할 때 자신을 업데이트하도록 Player를 관찰해야함
* PlayerCtrl가 점점 더 복잡해지면서 관리해야 하는 종속성에 대한 호출이 더 많아져 확장이 어려움
    + Ctrl간 연결을 옵저버 패턴을 사용하여 끊어 내는 것이 목표
<br></br>

1. Subject 추상 클래스 구현
> Subject.cs
```C#
using UnityEngine;
using System.Collections;

namespace _Observer
{
    public abstract class Subject: MonoBehaviour
    {
        private readonly ArrayList m_observers = new ArrayList();

        public void Attach(Observer observer)   // 옵저버 목록에 옵저버 객체를 추가한다.
        {
            m_observers.Add(observer);
        }

        public void Detach(Observer observer)   // 옵저버 목록에서 옵저버 객체를 제거한다.
        {
            m_observers.Remove(observer);
        }

        public void NotifyObservers()           // 옵저버 목록에 있는 객체에 알림을 보낸다.
        {
            foreach(Observer observer in m_observers)
                observer.Notify(this);
        }
    }
}
```
<br></br>

2. Observer 추상 클래스 구현
> Observer.cs
```C#
using UnityEngine;

namespace _Observer
{
    public abstract class Observer: MonoBehaviour
    {
        public abstract void Notify(Subject subject);
    }
} 
```
<br></br>

3. PlayerCtrl 클래스 작성
> PlayerCtrl.cs
```C#
using UnityEngine;

namespace _Observer
{
    public class PlayerCtrl: Subject
    {
        public bool IsRunning
        {
            get; private set;
        }

        public float CurrentHealth
        {
            get { return m_health; }
        }

        private bool m_is_live;
        private HUDCtrl m_hud_ctrl;
        private CameraCtrl m_camera_ctrl;

        [SerializeField]
        private float m_health = 100.0f;

        private void Awake()
        {
            m_hud_ctrl = gameObject.AddComponent<HUDCtrl>();
            m_camera_ctrl = (CameraCtrl)FindObjectOfType(typeof(CameraCtrl));
        }

        private void Start()
        {
            StartPlayer();
        }

        private void OnEnable()
        {
            if(m_hud_ctrl)
                Attach(m_hud_ctrl);

            if(m_camera_ctrl)
                Attach(m_camera_ctrl);
        }

        private void OnDisable()
        {
            if(m_hud_ctrl)
                Detach(m_hud_ctrl);
            
            if(m_camera_ctrl)
                Detach(m_camera_ctrl);
        }

        private void StartPlayer()
        {
            m_is_live = true;

            NotifyObservers();                  // PlayerCtrl은 HUDCtrl나 CameraCtrl를 직접 호출하지 않는다.
        }

        public void ToggleRunning()
        {
            if(m_is_live)
                IsRunning = !IsRunning;
            
            NotifyObservers();                  // PlayerCtrl은 HUDCtrl나 CameraCtrl를 직접 호출하지 않는다.
        }

        public void TakeDamage(float amount)
        {
            m_health -= amount;
            IsRunning = false;

            NotifyObservers();                  // PlayerCtrl은 HUDCtrl나 CameraCtrl를 직접 호출하지 않는다.

            if(m_health < 0)
                Destroy(gameObject);
        }
    }
}
```
<br></br>

4. 관찰자인 HUDCtrl을 구현한다.
> HUDCtrl.cs
```C#
using UnityEngine;

namespace _Observer
{
    public class HUDCtrl: Observer
    {
        private bool m_is_running;
        private float m_current_health;
        private PlayerCtrl m_player_ctrl;

        private void OnGUI()
        {
            GUILayout.BeginArea(new Rect(50, 50, 100, 200));
            GUILayout.BeginHorizontal("box");
            GUILayout.Label("Health: " + m_current_health);
            GUILayout.EndHorizontal();

            if(m_is_running)
            {
                GUILayout.BeginHorizontal("box");
                GUILayout.Label("Running!!");
                GUILayout.EndHorizontal();
            }

            if(m_current_health <= 50.0f)
            {
                GUILayout.BeginHorizontal("box");
                GUILayout.Label("WARNING: Low Health");
                GUILayout.EndHorizontal();
            }

            GUILayout.EndArea();
        }

        public override void Notify(Subject subject)
        {
            if(!m_player_ctrl)
                m_player_ctrl = subject.GetComponent<PlayerCtrl>();

                if(m_player_ctrl)
                {
                    m_is_running = m_player_ctrl.IsRunning;
                    m_current_health = m_player_ctrl.CurrentHealth;
                }
        }
    }
}
```
<br></br>

05. 관찰자인 CameraCtrl을 구현한다.
>CameraCtrl.cs
```C#
using UnityEngine;

namespace _Observer
{
    public class CameraCtrl: Observer
    {
        private bool m_is_running;
        private Vector3 m_initial_pos;
        private float m_shake_magnitude = 0.1f;
        private PlayerCtrl m_player_ctrl;

        private void OnEnable()
        {
            m_initial_pos = gameObject.transform.localPosition;
        }

        private void Update()
        {
            if(m_is_running)
                gameObject.transform.localPosition = m_initial_pos + (Random.insideUnitSphere * m_shake_magnitude);
            else
                gameObject.transform.localPosition = m_initial_pos;
        }

        public override void Notify(Subject subject)
        {
            if(!m_player_ctrl)
                m_player_ctrl = subject.GetComponent<PlayerCtrl>();
            
            if(m_player_ctrl)
                m_is_running = m_player_ctrl.IsRunning;
        }
    }
}
```
<br></br>

06. 옵저버 패턴의 클라이언트를 구현한다.
> ClientObserver.cs
```C#
using UnityEngine;

namespace _Observer
{
    public class ClientObserver: MonoBehaviour
    {
        private PlayerCtrl m_player_ctrl;

        private void Start()
        {
            m_player_ctrl = (PlayerCtrl)FindObjectOfType(typeof(PlayerCtrl));
        }

        private void OnGUI()
        {
            if(GUILayout.Button("Damage Player"))
                if(m_player_ctrl)
                    m_player_ctrl.TakeDamage(15.0f);
            
            if(GUILayout.Button("Run"))
                if(m_player_ctrl)
                    m_player_ctrl.ToggleRunning();
        }
    }
}
```